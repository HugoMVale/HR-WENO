var tipuesearch = {"pages":[{"title":" hrweno ","text":"hrweno API Documentation This is the main API documentation landing page generated by FORD . Developer Info HugoMVale","tags":"home","loc":"index.html"},{"title":"lax_friedrichs – hrweno","text":"public pure function lax_friedrichs(f, vm, vp, x, t, alpha) Arguments Type Intent Optional Attributes Name procedure(flux) :: f Monotone Lax-Friedrichs flux. It is more dissipative than the Godunov method, but \n computationally less demanding.\n   Source: Equation 2.72, page 21. ARGUMENTS:\n f      flux function f(v, x, t)\n vm     left (minus) reconstruction v_{i&#94;+1/2}&#94;-\n vp     right (plus) reconstruction v_{i&#94;+1/2}&#94;+ = v_{(i+1)&#94;+1/2}&#94;-\n x      x at flux interface, x_{i&#94;+1/2}\n t      time\n alpha  max(abs(f'(v))) in the domain on the problem NOTES:\n - Although potentially useful, this procedure cannot be defined as elemental ,\n   because it has a dummy procedure as input argument. real(kind=rk), intent(in) :: vm real(kind=rk), intent(in) :: vp real(kind=rk), intent(in) :: x real(kind=rk), intent(in) :: t real(kind=rk), intent(in) :: alpha Return Value real(kind=rk) Contents Source Code lax_friedrichs Source Code pure real ( rk ) function lax_friedrichs ( f , vm , vp , x , t , alpha ) !>----------------------------------------------------------------------------------------- !>   Monotone Lax-Friedrichs flux. It is more dissipative than the Godunov method, but !> computationally less demanding. !>   Source: Equation 2.72, page 21. !> !> ARGUMENTS: !> f      flux function f(v, x, t) !> vm     left (minus) reconstruction v_{i&#94;+1/2}&#94;- !> vp     right (plus) reconstruction v_{i&#94;+1/2}&#94;+ = v_{(i+1)&#94;+1/2}&#94;- !> x      x at flux interface, x_{i&#94;+1/2} !> t      time !> alpha  max(abs(f'(v))) in the domain on the problem !> !> NOTES: !> - Although potentially useful, this procedure cannot be defined as *elemental*, !>   because it has a dummy procedure as input argument. !>----------------------------------------------------------------------------------------- procedure ( flux ) :: f real ( rk ), intent ( in ) :: vm , vp , x , t , alpha lax_friedrichs = ( f ( vm , x , t ) + f ( vp , x , t ) - alpha * ( vp - vm )) / 2 end function lax_friedrichs","tags":"","loc":"proc\\lax_friedrichs.html"},{"title":"godunov – hrweno","text":"public pure function godunov(f, vm, vp, x, t) Arguments Type Intent Optional Attributes Name procedure(flux) :: f Monotone Godunov flux. It is less dissipative than the Lax-Friedrichs method, but \n computationally more demanding because of the if constructs.\n   Source: Equation 2.70, page 21. ARGUMENTS:\n f      flux function f(v, t)\n vm     left (minus) reconstruction v_{i&#94;+1/2}&#94;-\n vp     right (plus) reconstruction v_{i&#94;+1/2}&#94;+ = v_{(i+1)&#94;+1/2}&#94;-\n x      x at flux interface, x_{i&#94;+1/2}\n t      time NOTES:\n - See note about elemental in 'lax_friedrichs'. real(kind=rk), intent(in) :: vm real(kind=rk), intent(in) :: vp real(kind=rk), intent(in) :: x real(kind=rk), intent(in) :: t Return Value real(kind=rk) Contents Source Code godunov Source Code pure real ( rk ) function godunov ( f , vm , vp , x , t ) !>----------------------------------------------------------------------------------------- !>   Monotone Godunov flux. It is less dissipative than the Lax-Friedrichs method, but !> computationally more demanding because of the if constructs. !>   Source: Equation 2.70, page 21. !> !> ARGUMENTS: !> f      flux function f(v, t) !> vm     left (minus) reconstruction v_{i&#94;+1/2}&#94;- !> vp     right (plus) reconstruction v_{i&#94;+1/2}&#94;+ = v_{(i+1)&#94;+1/2}&#94;- !> x      x at flux interface, x_{i&#94;+1/2} !> t      time !> !> NOTES: !> - See note about *elemental* in 'lax_friedrichs'. !>----------------------------------------------------------------------------------------- procedure ( flux ) :: f real ( rk ), intent ( in ) :: vm , vp , x , t real ( rk ) :: fm , fp fm = f ( vm , x , t ) fp = f ( vp , x , t ) if ( vm <= vp ) then godunov = min ( fm , fp ) else godunov = max ( fm , fp ) end if end function godunov","tags":"","loc":"proc\\godunov.html"},{"title":"rktvd – hrweno","text":"public subroutine rktvd(fu, u, t, tout, dt, order, itask, istate) Check input conditions Algorthm selection\n------------------------------ 1st order RK (Euler) --------------------------------\nEquation (4.10), page 43.\n-------------------------------- 2nd order RK --------------------------------------\nEquation (4.10), page 43.\n-------------------------------- 3rd order RK --------------------------------------\nEquation (4.11), page 43. Arguments Type Intent Optional Attributes Name procedure(integrand) :: fu This subroutine implements the optimal 1st, 2nd and 3rd order TVD RK methods described\n in ICASE 97-65 (Shu, 1997).\n   The routine was built to work similarly to LSODE. ARGUMENTS:\n fu         function with the derivative u'(t)\n u          vector(N) with the variables to integrate u(t)\n t          time; on return it will be the current value of t (close to tout)\n tout       time where next output is desired\n dt         time step\n order      order of the method (1, 2 or 3)\n itask      flag incating the task to be performed\n            1   normal integration until tout\n            2   single dt step\n istate     flag indicating the state of the integration\n            1   first call for a problem\n            2   subsequent call for a problem INTERNAL VARIABLES:\n ui        vector(N) with intermediate value of u(t)\n udot      vector(N) with evaluated derivative of u(t) NOTES:\n - There are also 4th and 5th order methods, but they have lower CFL coeffiecients\n   and are more difficult to implement. See Equation 4.15, page 44. TO DO:\n - Adjust dt in final step to avoid overshoting tout by some fraction of 'dt'.\n - Maybe include an optional work array that could be transfered to 'fu'. real(kind=rk), intent(inout) :: u (:) real(kind=rk), intent(inout) :: t real(kind=rk), intent(in) :: tout real(kind=rk), intent(in) :: dt integer, intent(in) :: order integer, intent(in) :: itask integer, intent(inout) :: istate Contents Source Code rktvd Source Code subroutine rktvd ( fu , u , t , tout , dt , order , itask , istate ) !>----------------------------------------------------------------------------------------- !>   This subroutine implements the optimal 1st, 2nd and 3rd order TVD RK methods described !> in ICASE 97-65 (Shu, 1997). !>   The routine was built to work similarly to LSODE. !> !> ARGUMENTS: !> fu         function with the derivative u'(t) !> u          vector(N) with the variables to integrate u(t) !> t          time; on return it will be the current value of t (close to tout) !> tout       time where next output is desired !> dt         time step !> order      order of the method (1, 2 or 3) !> itask      flag incating the task to be performed !>            1   normal integration until tout !>            2   single dt step !> istate     flag indicating the state of the integration !>            1   first call for a problem !>            2   subsequent call for a problem !> !> INTERNAL VARIABLES: !> ui        vector(N) with intermediate value of u(t) !> udot      vector(N) with evaluated derivative of u(t) !> !> NOTES: !> - There are also 4th and 5th order methods, but they have lower CFL coeffiecients !>   and are more difficult to implement. See Equation 4.15, page 44. !> !> TO DO: !> - Adjust dt in final step to avoid overshoting tout by some fraction of 'dt'. !> - Maybe include an optional work array that could be transfered to 'fu'. !>----------------------------------------------------------------------------------------- procedure ( integrand ) :: fu real ( rk ), intent ( inout ) :: u (:), t real ( rk ), intent ( in ) :: tout , dt integer , intent ( in ) :: order , itask integer , intent ( inout ) :: istate character (:), allocatable :: msg real ( rk ), dimension ( size ( u )) :: ui , udot !> Check input conditions if ( isdone ( t , tout , dt )) return if ( istate == 1 ) then if ( order < 1 . or . order > 3 ) then msg = \"Invalid input 'order' in 'rktvd'. Valid range: 1 <= k <= 3.\" error stop msg end if if ( itask < 1 . or . itask > 2 ) then msg = \"Invalid input 'itask' in 'rktvd'. Valid set: {1, 2}.\" error stop msg end if istate = 2 else if ( istate < 1 . or . istate > 2 ) then msg = \"Invalid value 'istate' in 'rktvd'. Valid set: {1, 2}.\" error stop msg end if !> Algorthm selection select case ( order ) !> ------------------------------ 1st order RK (Euler) -------------------------------- !> Equation (4.10), page 43. case ( 1 ) do call fu ( t , u , udot ) u = u + dt * udot t = t + dt if ( isdone ( t , tout , dt ) . or . itask == 2 ) exit end do !> -------------------------------- 2nd order RK -------------------------------------- !> Equation (4.10), page 43. case ( 2 ) do call fu ( t , u , udot ) ui = u + dt * udot call fu ( t , ui , udot ) u = ( u + ui + dt * udot ) / 2 t = t + dt if ( isdone ( t , tout , dt ) . or . itask == 2 ) exit end do !> -------------------------------- 3rd order RK -------------------------------------- !> Equation (4.11), page 43. case ( 3 ) do call fu ( t , u , udot ) ui = u + dt * udot call fu ( t , ui , udot ) ui = ( 3 * u + ui + dt * udot ) / 4 call fu ( t , ui , udot ) u = ( u + 2 * ui + 2 * dt * udot ) / 3 t = t + dt if ( isdone ( t , tout , dt ) . or . itask == 2 ) exit end do end select end subroutine rktvd","tags":"","loc":"proc\\rktvd.html"},{"title":"mstvd – hrweno","text":"public subroutine mstvd(fu, u, t, tout, dt, uold, udotold, istate) Check input conditions The first starting values must be computed with a single-step method: we chose\nthe RK method of the same order.\nThe factor 2 in 't+2*dt' is not important, it just needs to be larger than 1.0\nso that one full 'dt' step can be computed. Equation (4.26), page 48. Shift u and udot values one step into the past Arguments Type Intent Optional Attributes Name procedure(integrand) :: fu This subroutine implements a 5-step, 3rd order TVD multi-step method described\n in ICASE 97-65 (Shu, 1997). In theory, this method should have an efficiency 1.5 times\n higher than the RK method of the same order. However, in practice they appear to be\n almost identical.\n   The routine was built to work similarly to LSODE. ARGUMENTS:\n fu            function with the derivative u'(t)\n u             vector(N) with variables to integrate u(t)\n t             time; on return it will be the current value of t (close to tout)\n tout          time where next output is desired\n dt            time step\n istate        flag indicating the state of the integration\n               1   first call for a problem\n               2   subsequent call for a problem\n uold          array(N,4) with the 4 previous values of u(t)\n udotold       array(N,4) with the 4 previous values of utot(t) INTERNAL VARIABLES:\n ui            vector(N) with intermediate value of u(t)\n udot          vector(N) with evaluated derivative of u(t) NOTES:\n - There is a 2nd order multi-step method, but the corresponding CFL value is half that\n   of the 2nd order RK method. Thus, thre is no reason to implement it. TO DO:\n - Maybe include an optional work array that could be transfered to 'fu'. real(kind=rk), intent(inout) :: u (:) real(kind=rk), intent(inout) :: t real(kind=rk), intent(in) :: tout real(kind=rk), intent(in) :: dt real(kind=rk), intent(inout) :: uold (:,:) real(kind=rk), intent(inout) :: udotold (:,:) integer, intent(inout) :: istate Contents Source Code mstvd Source Code subroutine mstvd ( fu , u , t , tout , dt , uold , udotold , istate ) !>----------------------------------------------------------------------------------------- !>   This subroutine implements a 5-step, 3rd order TVD multi-step method described !> in ICASE 97-65 (Shu, 1997). In theory, this method should have an efficiency 1.5 times !> higher than the RK method of the same order. However, in practice they appear to be !> almost identical. !>   The routine was built to work similarly to LSODE. !> !> ARGUMENTS: !> fu            function with the derivative u'(t) !> u             vector(N) with variables to integrate u(t) !> t             time; on return it will be the current value of t (close to tout) !> tout          time where next output is desired !> dt            time step !> istate        flag indicating the state of the integration !>               1   first call for a problem !>               2   subsequent call for a problem !> uold          array(N,4) with the 4 previous values of u(t) !> udotold       array(N,4) with the 4 previous values of utot(t) !> !> INTERNAL VARIABLES: !> ui            vector(N) with intermediate value of u(t) !> udot          vector(N) with evaluated derivative of u(t) !> !> NOTES: !> - There is a 2nd order multi-step method, but the corresponding CFL value is half that !>   of the 2nd order RK method. Thus, thre is no reason to implement it. !> !> TO DO: !> - Maybe include an optional work array that could be transfered to 'fu'. !>----------------------------------------------------------------------------------------- procedure ( integrand ) :: fu integer , parameter :: order = 3 real ( rk ), intent ( inout ) :: u (:), t , uold (:,:), udotold (:,:) real ( rk ), intent ( in ) :: tout , dt integer , intent ( inout ) :: istate real ( rk ), dimension ( size ( u )) :: ui , udot character (:), allocatable :: msg integer :: itask_rktvd , istate_rktvd , i !> Check input conditions if ( isdone ( t , tout , dt )) return if ( istate == 1 ) then if ( size ( uold , 2 ) /= 4 . or . size ( udotold , 2 ) /= 4 ) then msg = \"Invalid dimensions of arrays 'uold' or 'udotold' in 'mstvd'.\" error stop msg end if else if ( istate < 1 . or . istate > 2 ) then msg = \"Invalid input 'istate' in 'mstvd'. Valid set: {1, 2}.\" error stop msg end if !> The first starting values must be computed with a single-step method: we chose !> the RK method of the same order. !> The factor 2 in 't+2*dt' is not important, it just needs to be larger than 1.0 !> so that one full 'dt' step can be computed. if ( istate == 1 ) then itask_rktvd = 2 istate_rktvd = 1 do i = ( order + 1 ), 1 , - 1 uold (:, i ) = u call fu ( t , u , udotold (:, i )) call rktvd ( fu , u , t , t + 2 * dt , dt , order , itask_rktvd , istate_rktvd ) end do istate = 2 end if !> Equation (4.26), page 48. do if ( isdone ( t , tout , dt )) exit call fu ( t , u , udot ) ui = ( 25 * u + 50 * dt * udot + 7 * uold (:, 4 ) + 10 * dt * udotold (:, 4 )) / 32 t = t + dt !> Shift u and udot values one step into the past do i = order , 1 , - 1 udotold (:, i + 1 ) = udotold (:, i ) uold (:, i + 1 ) = uold (:, i ) end do udotold (:, 1 ) = udot uold (:, 1 ) = u u = ui end do end subroutine mstvd","tags":"","loc":"proc\\mstvd.html"},{"title":"wenok – hrweno","text":"public pure subroutine wenok(k, vext, vl, vr, eps, c) Select constant parameters according to order of the method\nCheck if user supplied grid\nAlgorithm\nObtain the 'k' reconstructed values vi+1/2(r) & vi-1/2(r)\nTodo: change to 'do concurrent'\nEquations 2.10, 2.51\nEquation 2.62 Equation 2.63 Equations 2.58-2.59 and procedure 2.2-4\nProcedure 2.2-5 Arguments Type Intent Optional Attributes Name integer, intent(in) :: k This subroutine implements the (2k-1)th order WENO method for arbitrary (uniform or\n non-uniform) finite volume/difference schemes described in ICASE 97-65 (Shu, 1997).\n   The method is applicable to scalar as well as multicomponent problems. In the later\n the reconstruction is applied in a component by component fashion.\n   Note that the procedure does not \"see\" the grid, so the reponsability of making sure \n that the grid is uniform (if the procedure is called without 'c') lies with the user.\n   The scheme below depics a generic finite volume discretization and the notation\n used (see ARGUMENTS). --0--|--1--| ...  |--(i-1)--|-------(i)-------|--(i+1)--| .... |--nc--|--(nc+1)---\n                             &#94;               &#94;\n                             vl(i)           vr(i)\n                             v_{i-1/2}&#94;+     v_{i+1/2}&#94;- The procedure can equally be used for finite difference methods. Tn that case, 'v'\n is not the average cell value, but rather the flux! See section 2.3.2, page 22. ARGUMENTS:\n k             order of reconstruction within the cell (k = 1, 2 or 3)\n vext          vector(1-(k-1):nc+(k-1)) of average cell values (if finite volume), extended with (k-1) ghost cells on each side\n vl            vector(1:nc) of reconstructed v at left boundary of cell i (v_{i-1/2}&#94;+)\n vr            vector(1:nc) of reconstructed v at right boundary of cell i (v_{i+1/2}&#94;-)\n eps           numerical smoothing factor\n c(j,r,i)      optional array(0:k-1,-1:k-1,1:nc) of constants for a non-uniform grid\n               (see calc_c) NOTES:\n - For a scalar 1D problem, this procedure is called once per time step. In contrast,\n   for a scalar 2D problem, it is called (nc1+nc2) times per step. So, efficiency is\n   very important. The current implementation is rather general in terms of order and\n   grid type, but at the cost of a number of 'select case' constructs. I wonder if it\n   would be wise to make a specific version for k=2 (3rd order) and uniform grids to get\n   maximum performance for multi-dimensional problems. real(kind=rk), intent(in) :: vext (2-k:) real(kind=rk), intent(out) :: vl (:) real(kind=rk), intent(out) :: vr (:) real(kind=rk), intent(in) :: eps real(kind=rk), intent(in), optional target :: c (0:,-1:,:) Contents Source Code wenok Source Code pure subroutine wenok ( k , vext , vl , vr , eps , c ) !>----------------------------------------------------------------------------------------- !>   This subroutine implements the (2k-1)th order WENO method for *arbitrary* (uniform or !> non-uniform) finite volume/difference schemes described in ICASE 97-65 (Shu, 1997). !>   The method is applicable to scalar as well as multicomponent problems. In the later !> the reconstruction is applied in a component by component fashion. !>   Note that the procedure does not \"see\" the grid, so the reponsability of making sure !> that the grid is uniform (if the procedure is called without 'c') lies with the user. !>   The scheme below depics a generic finite *volume* discretization and the notation !> used (see ARGUMENTS). !> !>    --0--|--1--| ...  |--(i-1)--|-------(i)-------|--(i+1)--| .... |--nc--|--(nc+1)--- !>                                 &#94;               &#94; !>                                 vl(i)           vr(i) !>                                 v_{i-1/2}&#94;+     v_{i+1/2}&#94;- !> !>   The procedure can equally be used for finite difference methods. Tn that case, 'v' !> is not the average cell value, but rather the flux! See section 2.3.2, page 22. !> !> ARGUMENTS: !> k             order of reconstruction within the cell (k = 1, 2 or 3) !> vext          vector(1-(k-1):nc+(k-1)) of *average* cell values (if finite volume), !>               *extended* with (k-1) ghost cells on each side !> vl            vector(1:nc) of reconstructed v at left boundary of cell i (v_{i-1/2}&#94;+) !> vr            vector(1:nc) of reconstructed v at right boundary of cell i (v_{i+1/2}&#94;-) !> eps           numerical smoothing factor !> c(j,r,i)      optional array(0:k-1,-1:k-1,1:nc) of constants for a *non-uniform* grid !>               (see calc_c) !> !> NOTES: !> - For a scalar 1D problem, this procedure is called once per time step. In contrast, !>   for a scalar 2D problem, it is called (nc1+nc2) times per step. So, efficiency is !>   very important. The current implementation is rather general in terms of order and !>   grid type, but at the cost of a number of 'select case' constructs. I wonder if it !>   would be wise to make a specific version for k=2 (3rd order) and uniform grids to get !>   maximum performance for multi-dimensional problems. !>----------------------------------------------------------------------------------------- integer , intent ( in ) :: k real ( rk ), intent ( in ) :: eps , vext ( 2 - k :) real ( rk ), intent ( out ) :: vl (:), vr (:) real ( rk ), intent ( in ), target , optional :: c ( 0 :, - 1 :,:) real ( rk ), dimension ( 0 : k - 1 ) :: vlr , vrr , w , wtilde , alfa , alfatilde , beta real ( rk ), allocatable :: d (:), ci (:,:) integer :: i , r , nc logical :: usrgrid character (:), allocatable :: msg !> Select constant parameters according to order of the method select case ( k ) case ( 1 ) d = d1 ci = c1 case ( 2 ) d = d2 ci = c2 case ( 3 ) d = d3 ci = c3 case default msg = \"Invalid input 'k' in 'wenok'. Valid range: 1 <= k <= 3.\" error stop msg end select !> Check if user supplied grid if ( present ( c )) then usrgrid = . true . else usrgrid = . false . end if !> Algorithm !> Obtain the 'k' reconstructed values vi+1/2(r) & vi-1/2(r) !> Todo: change to 'do concurrent' nc = size ( vl ) do i = 1 , nc !> Equations 2.10, 2.51 if ( usrgrid ) ci = c (:,:, i ) do r = 0 , k - 1 vrr ( r ) = sum ( ci (:, r ) * vext ( i - r : i - r + k - 1 )) vlr ( r ) = sum ( ci (:, r - 1 ) * vext ( i - r : i - r + k - 1 )) end do select case ( k ) case ( 1 ) beta ( 0 ) = 0._rk !> Equation 2.62 case ( 2 ) beta ( 0 ) = ( vext ( i + 1 ) - vext ( i )) ** 2 beta ( 1 ) = ( vext ( i ) - vext ( i - 1 )) ** 2 !> Equation 2.63 case ( 3 ) beta ( 0 ) = 1 3._rk / 12 * ( vext ( i ) - 2 * vext ( i + 1 ) + vext ( i + 2 )) ** 2 & + 1._rk / 4 * ( 3 * vext ( i ) - 4 * vext ( i + 1 ) + vext ( i + 2 )) ** 2 beta ( 1 ) = 1 3._rk / 12 * ( vext ( i - 1 ) - 2 * vext ( i ) + vext ( i + 1 )) ** 2 & + 1._rk / 4 * ( vext ( i - 1 ) - vext ( i + 1 )) ** 2 beta ( 2 ) = 1 3._rk / 12 * ( vext ( i - 2 ) - 2 * vext ( i - 1 ) + vext ( i )) ** 2 & + 1._rk / 4 * ( vext ( i - 2 ) - 4 * vext ( i - 1 ) + 3 * vext ( i )) ** 2 end select !> Equations 2.58-2.59 and procedure 2.2-4 alfa = d / ( eps + beta ) ** 2 alfatilde = d ( k - 1 : 0 : - 1 ) / ( eps + beta ) ** 2 w = alfa / sum ( alfa ) wtilde = alfatilde / sum ( alfatilde ) !> Procedure 2.2-5 vr ( i ) = sum ( w * vrr ) vl ( i ) = sum ( wtilde * vlr ) end do end subroutine wenok","tags":"","loc":"proc\\wenok.html"},{"title":"calc_c – hrweno","text":"public pure subroutine calc_c(k, xedges, c) Check input conditions\nAllocate extended grid with (k+1) ghost cells on each side\nExtend to the left linearly\nExtend to the right linearly\nGet pointers to left and right cell boundaries\nCompute array of constants 'c' for each grid position\nEquation 2.20, page 6. Arguments Type Intent Optional Attributes Name integer, intent(in) :: k This subroutine computes the array of constants 'c(j,r,i)' required to use 'wenok' with\n non-uniform grids. ARGUMENTS:\n k             order (>=1) of reconstruction within the cell\n xedges(i)     vector(0:nc) of cell edges\n c(j,r,i)      array(0:k-1,-1:k-1,1:nc) of constants for a non-uniform grid NOTES:\n - This procedure is only called a very small of times (as many as the number of spatial\n   dimensions) at the start of the simulation. So, there is no point in doing complex\n   optimizations. real(kind=rk), intent(in) :: xedges (0:) real(kind=rk), intent(out) :: c (0:,-1:,:) Contents Source Code calc_c Source Code pure subroutine calc_c ( k , xedges , c ) !>----------------------------------------------------------------------------------------- !>   This subroutine computes the array of constants 'c(j,r,i)' required to use 'wenok' with !> non-uniform grids. !> !> ARGUMENTS: !> k             order (>=1) of reconstruction within the cell !> xedges(i)     vector(0:nc) of cell edges !                xedges(i) is the value of x at right boundary of cell i (x_{i+1/2}) !                xedges(i-1) is the value of x at left boundary of cell i (x_{i-1/2}) !> c(j,r,i)      array(0:k-1,-1:k-1,1:nc) of constants for a non-uniform grid !> !> NOTES: !> - This procedure is only called a very small of times (as many as the number of spatial !>   dimensions) at the *start* of the simulation. So, there is no point in doing complex !>   optimizations. !>----------------------------------------------------------------------------------------- integer , intent ( in ) :: k real ( rk ), intent ( in ) :: xedges ( 0 :) real ( rk ), intent ( out ) :: c ( 0 :, - 1 :,:) real ( rk ) :: prod1 , prod2 , sum1 , sum2 , dx real ( rk ), allocatable , target :: xext (:) real ( rk ), dimension (:), pointer :: xl , xr integer :: i , j , l , nc , ng , m , q , r character (:), allocatable :: msg !> Check input conditions if ( k < 1 ) then msg = \"Invalid input 'k' in 'calc_c'. Valid range: k >= 1.\" error stop msg end if if ( k > 3 ) then msg = \"Input 'k' is probably too high in 'calc_c'. Usual range: k <= 3.\" error stop msg end if if ( ubound ( c , 1 ) /= k - 1 ) then msg = \"Invalid ubound(c,1) in 'calc_c'.\" error stop msg end if if ( ubound ( c , 2 ) /= k - 1 ) then msg = \"Invalid ubound(cgrid,2) in 'calc_c'.\" error stop msg end if nc = ubound ( xedges , 1 ) if ( ubound ( c , 3 ) /= nc ) then msg = \"Invalid ubound(cgrid,3) in 'calc_c'.\" error stop msg end if !> Allocate extended grid with (k+1) ghost cells on each side ng = k + 1 allocate ( xext ( 0 - ng : nc + ng )) xext ( 0 : nc ) = xedges !> Extend to the left linearly dx = xext ( 1 ) - xext ( 0 ) do i = - 1 , lbound ( xext , 1 ), - 1 xext ( i ) = xext ( i + 1 ) - dx end do !> Extend to the right linearly dx = xext ( nc ) - xext ( nc - 1 ) do i = nc + 1 , ubound ( xext , 1 ) xext ( i ) = xext ( i - 1 ) + dx end do !> Get pointers to left and right cell boundaries xl ( 1 - ng :) => xext ( lbound ( xext , 1 ): ubound ( xext , 1 ) - 1 ) xr ( 1 - ng :) => xext ( lbound ( xext , 1 ) + 1 : ubound ( xext , 1 )) !> Compute array of constants 'c' for each grid position !> Equation 2.20, page 6. do i = 1 , nc do r = - 1 , k - 1 do j = 0 , k - 1 sum2 = 0._rk do m = j + 1 , k prod2 = 1._rk do l = 0 , k if ( l == m ) cycle prod2 = prod2 * ( xl ( i - r + m ) - xl ( i - r + l )) end do sum1 = 0._rk do l = 0 , k if ( l == m ) cycle prod1 = 1._rk do q = 0 , k if ( q == m . or . q == l ) cycle prod1 = prod1 * ( xr ( i ) - xl ( i - r + q )) end do sum1 = sum1 + prod1 end do sum2 = sum2 + sum1 / prod2 end do c ( j , r , i ) = sum2 * ( xr ( i - r + j ) - xl ( i - r + j )) end do end do end do end subroutine calc_c","tags":"","loc":"proc\\calc_c.html"},{"title":"hrutils – hrweno","text":"This module contains basic flux schemes for scalar problems. They are mostly intented\n to help test the other modules. Note that the WENO schemes are not restricted to scalar\n problems! \n   Source: ICASE 97-65 by Shu, 1997. Uses iso_fortran_env Contents Functions lax_friedrichs godunov Functions public pure function lax_friedrichs (f, vm, vp, x, t, alpha) Arguments Type Intent Optional Attributes Name procedure(flux) :: f Monotone Lax-Friedrichs flux. It is more dissipative than the Godunov method, but \n computationally less demanding.\n   Source: Equation 2.72, page 21. ARGUMENTS:\n f      flux function f(v, x, t)\n vm     left (minus) reconstruction v_{i&#94;+1/2}&#94;-\n vp     right (plus) reconstruction v_{i&#94;+1/2}&#94;+ = v_{(i+1)&#94;+1/2}&#94;-\n x      x at flux interface, x_{i&#94;+1/2}\n t      time\n alpha  max(abs(f'(v))) in the domain on the problem NOTES:\n - Although potentially useful, this procedure cannot be defined as elemental ,\n   because it has a dummy procedure as input argument. real(kind=rk), intent(in) :: vm real(kind=rk), intent(in) :: vp real(kind=rk), intent(in) :: x real(kind=rk), intent(in) :: t real(kind=rk), intent(in) :: alpha Return Value real(kind=rk) public pure function godunov (f, vm, vp, x, t) Arguments Type Intent Optional Attributes Name procedure(flux) :: f Monotone Godunov flux. It is less dissipative than the Lax-Friedrichs method, but \n computationally more demanding because of the if constructs.\n   Source: Equation 2.70, page 21. ARGUMENTS:\n f      flux function f(v, t)\n vm     left (minus) reconstruction v_{i&#94;+1/2}&#94;-\n vp     right (plus) reconstruction v_{i&#94;+1/2}&#94;+ = v_{(i+1)&#94;+1/2}&#94;-\n x      x at flux interface, x_{i&#94;+1/2}\n t      time NOTES:\n - See note about elemental in 'lax_friedrichs'. real(kind=rk), intent(in) :: vm real(kind=rk), intent(in) :: vp real(kind=rk), intent(in) :: x real(kind=rk), intent(in) :: t Return Value real(kind=rk)","tags":"","loc":"module\\hrutils.html"},{"title":"tvdode – hrweno","text":"This module contains two TVD (total variation diminishing) high-order schemes for solving\n initial value problems. It is very important to use TVD schemes for time integration. Even\n with a TVD spacial discretization, if the time discretization is done by a non-TVD method,\n the result may be oscillatory.\n   Source: ICASE 97-65 by Shu, 1997. Uses iso_fortran_env Contents Subroutines rktvd mstvd Subroutines public subroutine rktvd (fu, u, t, tout, dt, order, itask, istate) Check input conditions Read more… Arguments Type Intent Optional Attributes Name procedure(integrand) :: fu This subroutine implements the optimal 1st, 2nd and 3rd order TVD RK methods described\n in ICASE 97-65 (Shu, 1997).\n   The routine was built to work similarly to LSODE. ARGUMENTS:\n fu         function with the derivative u'(t)\n u          vector(N) with the variables to integrate u(t)\n t          time; on return it will be the current value of t (close to tout)\n tout       time where next output is desired\n dt         time step\n order      order of the method (1, 2 or 3)\n itask      flag incating the task to be performed\n            1   normal integration until tout\n            2   single dt step\n istate     flag indicating the state of the integration\n            1   first call for a problem\n            2   subsequent call for a problem INTERNAL VARIABLES:\n ui        vector(N) with intermediate value of u(t)\n udot      vector(N) with evaluated derivative of u(t) NOTES:\n - There are also 4th and 5th order methods, but they have lower CFL coeffiecients\n   and are more difficult to implement. See Equation 4.15, page 44. TO DO:\n - Adjust dt in final step to avoid overshoting tout by some fraction of 'dt'.\n - Maybe include an optional work array that could be transfered to 'fu'. real(kind=rk), intent(inout) :: u (:) real(kind=rk), intent(inout) :: t real(kind=rk), intent(in) :: tout real(kind=rk), intent(in) :: dt integer, intent(in) :: order integer, intent(in) :: itask integer, intent(inout) :: istate public subroutine mstvd (fu, u, t, tout, dt, uold, udotold, istate) Check input conditions Read more… Arguments Type Intent Optional Attributes Name procedure(integrand) :: fu This subroutine implements a 5-step, 3rd order TVD multi-step method described\n in ICASE 97-65 (Shu, 1997). In theory, this method should have an efficiency 1.5 times\n higher than the RK method of the same order. However, in practice they appear to be\n almost identical.\n   The routine was built to work similarly to LSODE. ARGUMENTS:\n fu            function with the derivative u'(t)\n u             vector(N) with variables to integrate u(t)\n t             time; on return it will be the current value of t (close to tout)\n tout          time where next output is desired\n dt            time step\n istate        flag indicating the state of the integration\n               1   first call for a problem\n               2   subsequent call for a problem\n uold          array(N,4) with the 4 previous values of u(t)\n udotold       array(N,4) with the 4 previous values of utot(t) INTERNAL VARIABLES:\n ui            vector(N) with intermediate value of u(t)\n udot          vector(N) with evaluated derivative of u(t) NOTES:\n - There is a 2nd order multi-step method, but the corresponding CFL value is half that\n   of the 2nd order RK method. Thus, thre is no reason to implement it. TO DO:\n - Maybe include an optional work array that could be transfered to 'fu'. real(kind=rk), intent(inout) :: u (:) real(kind=rk), intent(inout) :: t real(kind=rk), intent(in) :: tout real(kind=rk), intent(in) :: dt real(kind=rk), intent(inout) :: uold (:,:) real(kind=rk), intent(inout) :: udotold (:,:) integer, intent(inout) :: istate","tags":"","loc":"module\\tvdode.html"},{"title":"weno – hrweno","text":"This module contains a collection of high-resolution weighted essentially non-oscillatory\n (WENO) schemes for arbitrary (uniform or non-uniform) finite volume/difference methods.\n   Source: ICASE 97-65 by Shu, 1997. Uses iso_fortran_env Contents Variables c1 c2 c3 Subroutines wenok calc_c Variables Type Visibility Attributes Name Initial real(kind=rk), public, parameter :: c1 (0:0,-1:0) = reshape([1._rk, 1._rk], [1, 2], order=[1, 2]) real(kind=rk), public, parameter :: c2 (0:1,-1:1) = reshape([3._rk/2, -1._rk/2, 1._rk/2, 1._rk/2, -1._rk/2, 3._rk/2], [2, 3], order=[1, 2]) real(kind=rk), public, parameter :: c3 (0:2,-1:2) = reshape([11._rk/6, -7._rk/6, 1._rk/3, 1._rk/3, 5._rk/6, -1._rk/6, -1._rk/6, 5._rk/6, 1._rk/3, 1._rk/3, -7._rk/6, 11._rk/6], [3, 4], order=[1, 2]) Subroutines public pure subroutine wenok (k, vext, vl, vr, eps, c) Select constant parameters according to order of the method\nCheck if user supplied grid\nAlgorithm\nObtain the 'k' reconstructed values vi+1/2(r) & vi-1/2(r)\nTodo: change to 'do concurrent'\nEquations 2.10, 2.51\nEquation 2.62 Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: k This subroutine implements the (2k-1)th order WENO method for arbitrary (uniform or\n non-uniform) finite volume/difference schemes described in ICASE 97-65 (Shu, 1997).\n   The method is applicable to scalar as well as multicomponent problems. In the later\n the reconstruction is applied in a component by component fashion.\n   Note that the procedure does not \"see\" the grid, so the reponsability of making sure \n that the grid is uniform (if the procedure is called without 'c') lies with the user.\n   The scheme below depics a generic finite volume discretization and the notation\n used (see ARGUMENTS). --0--|--1--| ...  |--(i-1)--|-------(i)-------|--(i+1)--| .... |--nc--|--(nc+1)---\n                             &#94;               &#94;\n                             vl(i)           vr(i)\n                             v_{i-1/2}&#94;+     v_{i+1/2}&#94;- The procedure can equally be used for finite difference methods. Tn that case, 'v'\n is not the average cell value, but rather the flux! See section 2.3.2, page 22. ARGUMENTS:\n k             order of reconstruction within the cell (k = 1, 2 or 3)\n vext          vector(1-(k-1):nc+(k-1)) of average cell values (if finite volume), extended with (k-1) ghost cells on each side\n vl            vector(1:nc) of reconstructed v at left boundary of cell i (v_{i-1/2}&#94;+)\n vr            vector(1:nc) of reconstructed v at right boundary of cell i (v_{i+1/2}&#94;-)\n eps           numerical smoothing factor\n c(j,r,i)      optional array(0:k-1,-1:k-1,1:nc) of constants for a non-uniform grid\n               (see calc_c) NOTES:\n - For a scalar 1D problem, this procedure is called once per time step. In contrast,\n   for a scalar 2D problem, it is called (nc1+nc2) times per step. So, efficiency is\n   very important. The current implementation is rather general in terms of order and\n   grid type, but at the cost of a number of 'select case' constructs. I wonder if it\n   would be wise to make a specific version for k=2 (3rd order) and uniform grids to get\n   maximum performance for multi-dimensional problems. real(kind=rk), intent(in) :: vext (2-k:) real(kind=rk), intent(out) :: vl (:) real(kind=rk), intent(out) :: vr (:) real(kind=rk), intent(in) :: eps real(kind=rk), intent(in), optional target :: c (0:,-1:,:) public pure subroutine calc_c (k, xedges, c) Check input conditions\nAllocate extended grid with (k+1) ghost cells on each side\nExtend to the left linearly\nExtend to the right linearly\nGet pointers to left and right cell boundaries\nCompute array of constants 'c' for each grid position\nEquation 2.20, page 6. Arguments Type Intent Optional Attributes Name integer, intent(in) :: k This subroutine computes the array of constants 'c(j,r,i)' required to use 'wenok' with\n non-uniform grids. ARGUMENTS:\n k             order (>=1) of reconstruction within the cell\n xedges(i)     vector(0:nc) of cell edges\n c(j,r,i)      array(0:k-1,-1:k-1,1:nc) of constants for a non-uniform grid NOTES:\n - This procedure is only called a very small of times (as many as the number of spatial\n   dimensions) at the start of the simulation. So, there is no point in doing complex\n   optimizations. real(kind=rk), intent(in) :: xedges (0:) real(kind=rk), intent(out) :: c (0:,-1:,:)","tags":"","loc":"module\\weno.html"},{"title":"hrutils.f90 – hrweno","text":"Contents Modules hrutils Source Code hrutils.f90 Source Code module hrutils !>--------------------------------------------------------------------------------------------- !>   This module contains basic flux schemes for *scalar* problems. They are mostly intented !> to help test the other modules. Note that the WENO schemes are *not* restricted to scalar !> problems! !>   Source: ICASE 97-65 by Shu, 1997. !>--------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : real64 implicit none private public :: lax_friedrichs , godunov integer , parameter :: rk = real64 abstract interface pure function flux ( u , x , t ) import :: rk real ( rk ) :: flux real ( rk ), intent ( in ) :: u , x , t end function end interface ! type :: grid1 !     real(rk), allocatable :: edges(:), c(:), d(:) !     real(rk), dimension(:), pointer :: l, r !     integer :: nc ! end type contains pure real ( rk ) function lax_friedrichs ( f , vm , vp , x , t , alpha ) !>----------------------------------------------------------------------------------------- !>   Monotone Lax-Friedrichs flux. It is more dissipative than the Godunov method, but !> computationally less demanding. !>   Source: Equation 2.72, page 21. !> !> ARGUMENTS: !> f      flux function f(v, x, t) !> vm     left (minus) reconstruction v_{i&#94;+1/2}&#94;- !> vp     right (plus) reconstruction v_{i&#94;+1/2}&#94;+ = v_{(i+1)&#94;+1/2}&#94;- !> x      x at flux interface, x_{i&#94;+1/2} !> t      time !> alpha  max(abs(f'(v))) in the domain on the problem !> !> NOTES: !> - Although potentially useful, this procedure cannot be defined as *elemental*, !>   because it has a dummy procedure as input argument. !>----------------------------------------------------------------------------------------- procedure ( flux ) :: f real ( rk ), intent ( in ) :: vm , vp , x , t , alpha lax_friedrichs = ( f ( vm , x , t ) + f ( vp , x , t ) - alpha * ( vp - vm )) / 2 end function lax_friedrichs pure real ( rk ) function godunov ( f , vm , vp , x , t ) !>----------------------------------------------------------------------------------------- !>   Monotone Godunov flux. It is less dissipative than the Lax-Friedrichs method, but !> computationally more demanding because of the if constructs. !>   Source: Equation 2.70, page 21. !> !> ARGUMENTS: !> f      flux function f(v, t) !> vm     left (minus) reconstruction v_{i&#94;+1/2}&#94;- !> vp     right (plus) reconstruction v_{i&#94;+1/2}&#94;+ = v_{(i+1)&#94;+1/2}&#94;- !> x      x at flux interface, x_{i&#94;+1/2} !> t      time !> !> NOTES: !> - See note about *elemental* in 'lax_friedrichs'. !>----------------------------------------------------------------------------------------- procedure ( flux ) :: f real ( rk ), intent ( in ) :: vm , vp , x , t real ( rk ) :: fm , fp fm = f ( vm , x , t ) fp = f ( vp , x , t ) if ( vm <= vp ) then godunov = min ( fm , fp ) else godunov = max ( fm , fp ) end if end function godunov end module hrutils","tags":"","loc":"sourcefile\\hrutils.f90.html"},{"title":"tvdode.f90 – hrweno","text":"Contents Modules tvdode Source Code tvdode.f90 Source Code module tvdode !>--------------------------------------------------------------------------------------------- !>   This module contains two TVD (total variation diminishing) high-order schemes for solving !> initial value problems. It is very important to use TVD schemes for time integration. Even !> with a TVD spacial discretization, if the time discretization is done by a non-TVD method, !> the result may be oscillatory. !>   Source: ICASE 97-65 by Shu, 1997. !>--------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : real64 implicit none private public :: rktvd , mstvd integer , parameter :: rk = real64 abstract interface pure subroutine integrand ( t , u , udot ) import :: rk real ( rk ), intent ( in ) :: t , u (:) real ( rk ), intent ( out ) :: udot (:) end subroutine end interface contains subroutine rktvd ( fu , u , t , tout , dt , order , itask , istate ) !>----------------------------------------------------------------------------------------- !>   This subroutine implements the optimal 1st, 2nd and 3rd order TVD RK methods described !> in ICASE 97-65 (Shu, 1997). !>   The routine was built to work similarly to LSODE. !> !> ARGUMENTS: !> fu         function with the derivative u'(t) !> u          vector(N) with the variables to integrate u(t) !> t          time; on return it will be the current value of t (close to tout) !> tout       time where next output is desired !> dt         time step !> order      order of the method (1, 2 or 3) !> itask      flag incating the task to be performed !>            1   normal integration until tout !>            2   single dt step !> istate     flag indicating the state of the integration !>            1   first call for a problem !>            2   subsequent call for a problem !> !> INTERNAL VARIABLES: !> ui        vector(N) with intermediate value of u(t) !> udot      vector(N) with evaluated derivative of u(t) !> !> NOTES: !> - There are also 4th and 5th order methods, but they have lower CFL coeffiecients !>   and are more difficult to implement. See Equation 4.15, page 44. !> !> TO DO: !> - Adjust dt in final step to avoid overshoting tout by some fraction of 'dt'. !> - Maybe include an optional work array that could be transfered to 'fu'. !>----------------------------------------------------------------------------------------- procedure ( integrand ) :: fu real ( rk ), intent ( inout ) :: u (:), t real ( rk ), intent ( in ) :: tout , dt integer , intent ( in ) :: order , itask integer , intent ( inout ) :: istate character (:), allocatable :: msg real ( rk ), dimension ( size ( u )) :: ui , udot !> Check input conditions if ( isdone ( t , tout , dt )) return if ( istate == 1 ) then if ( order < 1 . or . order > 3 ) then msg = \"Invalid input 'order' in 'rktvd'. Valid range: 1 <= k <= 3.\" error stop msg end if if ( itask < 1 . or . itask > 2 ) then msg = \"Invalid input 'itask' in 'rktvd'. Valid set: {1, 2}.\" error stop msg end if istate = 2 else if ( istate < 1 . or . istate > 2 ) then msg = \"Invalid value 'istate' in 'rktvd'. Valid set: {1, 2}.\" error stop msg end if !> Algorthm selection select case ( order ) !> ------------------------------ 1st order RK (Euler) -------------------------------- !> Equation (4.10), page 43. case ( 1 ) do call fu ( t , u , udot ) u = u + dt * udot t = t + dt if ( isdone ( t , tout , dt ) . or . itask == 2 ) exit end do !> -------------------------------- 2nd order RK -------------------------------------- !> Equation (4.10), page 43. case ( 2 ) do call fu ( t , u , udot ) ui = u + dt * udot call fu ( t , ui , udot ) u = ( u + ui + dt * udot ) / 2 t = t + dt if ( isdone ( t , tout , dt ) . or . itask == 2 ) exit end do !> -------------------------------- 3rd order RK -------------------------------------- !> Equation (4.11), page 43. case ( 3 ) do call fu ( t , u , udot ) ui = u + dt * udot call fu ( t , ui , udot ) ui = ( 3 * u + ui + dt * udot ) / 4 call fu ( t , ui , udot ) u = ( u + 2 * ui + 2 * dt * udot ) / 3 t = t + dt if ( isdone ( t , tout , dt ) . or . itask == 2 ) exit end do end select end subroutine rktvd subroutine mstvd ( fu , u , t , tout , dt , uold , udotold , istate ) !>----------------------------------------------------------------------------------------- !>   This subroutine implements a 5-step, 3rd order TVD multi-step method described !> in ICASE 97-65 (Shu, 1997). In theory, this method should have an efficiency 1.5 times !> higher than the RK method of the same order. However, in practice they appear to be !> almost identical. !>   The routine was built to work similarly to LSODE. !> !> ARGUMENTS: !> fu            function with the derivative u'(t) !> u             vector(N) with variables to integrate u(t) !> t             time; on return it will be the current value of t (close to tout) !> tout          time where next output is desired !> dt            time step !> istate        flag indicating the state of the integration !>               1   first call for a problem !>               2   subsequent call for a problem !> uold          array(N,4) with the 4 previous values of u(t) !> udotold       array(N,4) with the 4 previous values of utot(t) !> !> INTERNAL VARIABLES: !> ui            vector(N) with intermediate value of u(t) !> udot          vector(N) with evaluated derivative of u(t) !> !> NOTES: !> - There is a 2nd order multi-step method, but the corresponding CFL value is half that !>   of the 2nd order RK method. Thus, thre is no reason to implement it. !> !> TO DO: !> - Maybe include an optional work array that could be transfered to 'fu'. !>----------------------------------------------------------------------------------------- procedure ( integrand ) :: fu integer , parameter :: order = 3 real ( rk ), intent ( inout ) :: u (:), t , uold (:,:), udotold (:,:) real ( rk ), intent ( in ) :: tout , dt integer , intent ( inout ) :: istate real ( rk ), dimension ( size ( u )) :: ui , udot character (:), allocatable :: msg integer :: itask_rktvd , istate_rktvd , i !> Check input conditions if ( isdone ( t , tout , dt )) return if ( istate == 1 ) then if ( size ( uold , 2 ) /= 4 . or . size ( udotold , 2 ) /= 4 ) then msg = \"Invalid dimensions of arrays 'uold' or 'udotold' in 'mstvd'.\" error stop msg end if else if ( istate < 1 . or . istate > 2 ) then msg = \"Invalid input 'istate' in 'mstvd'. Valid set: {1, 2}.\" error stop msg end if !> The first starting values must be computed with a single-step method: we chose !> the RK method of the same order. !> The factor 2 in 't+2*dt' is not important, it just needs to be larger than 1.0 !> so that one full 'dt' step can be computed. if ( istate == 1 ) then itask_rktvd = 2 istate_rktvd = 1 do i = ( order + 1 ), 1 , - 1 uold (:, i ) = u call fu ( t , u , udotold (:, i )) call rktvd ( fu , u , t , t + 2 * dt , dt , order , itask_rktvd , istate_rktvd ) end do istate = 2 end if !> Equation (4.26), page 48. do if ( isdone ( t , tout , dt )) exit call fu ( t , u , udot ) ui = ( 25 * u + 50 * dt * udot + 7 * uold (:, 4 ) + 10 * dt * udotold (:, 4 )) / 32 t = t + dt !> Shift u and udot values one step into the past do i = order , 1 , - 1 udotold (:, i + 1 ) = udotold (:, i ) uold (:, i + 1 ) = uold (:, i ) end do udotold (:, 1 ) = udot uold (:, 1 ) = u u = ui end do end subroutine mstvd pure function isdone ( t , tout , dt ) !>----------------------------------------------------------------------------------------- !> Aux function to check if the integration is finished. !> !> ARGUMENTS: !> t        current time !> tout     time where next output is desired !> dt       time step !>----------------------------------------------------------------------------------------- real ( rk ), intent ( in ) :: t , tout , dt logical :: isdone isdone = ( t - tout ) * sign ( 1._rk , dt ) > 0._rk end function isdone end module tvdode","tags":"","loc":"sourcefile\\tvdode.f90.html"},{"title":"weno.f90 – hrweno","text":"Contents Modules weno Source Code weno.f90 Source Code module weno !>--------------------------------------------------------------------------------------------- !>   This module contains a collection of high-resolution weighted essentially non-oscillatory !> (WENO) schemes for *arbitrary* (uniform or non-uniform) finite volume/difference methods. !>   Source: ICASE 97-65 by Shu, 1997. !>--------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : real64 implicit none private public :: wenok , calc_c , c1 , c2 , c3 integer , parameter :: rk = real64 !> Parameter arrays for WENO methods real ( rk ), parameter :: d1 ( 0 : 0 ) = 1._rk , & d2 ( 0 : 1 ) = [ 2._rk / 3_rk , 1._rk / 3_rk ], & d3 ( 0 : 2 ) = [ 0.3_rk , 0.6_rk , 0.1_rk ] real ( rk ), parameter :: & c1 ( 0 : 0 , - 1 : 0 ) = reshape ([ 1._rk , 1._rk ], [ 1 , 2 ], order = [ 1 , 2 ]), & c2 ( 0 : 1 , - 1 : 1 ) = reshape ([ 3._rk / 2 , - 1._rk / 2 , 1._rk / 2 , 1._rk / 2 , - 1._rk / 2 , 3._rk / 2 ], & [ 2 , 3 ], order = [ 1 , 2 ]), & c3 ( 0 : 2 , - 1 : 2 ) = reshape ([ 1 1._rk / 6 , - 7._rk / 6 , 1._rk / 3 , 1._rk / 3 , 5._rk / 6 , - 1._rk / 6 , & - 1._rk / 6 , 5._rk / 6 , 1._rk / 3 , 1._rk / 3 , - 7._rk / 6 , 1 1._rk / 6 ], & [ 3 , 4 ], order = [ 1 , 2 ]) contains pure subroutine wenok ( k , vext , vl , vr , eps , c ) !>----------------------------------------------------------------------------------------- !>   This subroutine implements the (2k-1)th order WENO method for *arbitrary* (uniform or !> non-uniform) finite volume/difference schemes described in ICASE 97-65 (Shu, 1997). !>   The method is applicable to scalar as well as multicomponent problems. In the later !> the reconstruction is applied in a component by component fashion. !>   Note that the procedure does not \"see\" the grid, so the reponsability of making sure !> that the grid is uniform (if the procedure is called without 'c') lies with the user. !>   The scheme below depics a generic finite *volume* discretization and the notation !> used (see ARGUMENTS). !> !>    --0--|--1--| ...  |--(i-1)--|-------(i)-------|--(i+1)--| .... |--nc--|--(nc+1)--- !>                                 &#94;               &#94; !>                                 vl(i)           vr(i) !>                                 v_{i-1/2}&#94;+     v_{i+1/2}&#94;- !> !>   The procedure can equally be used for finite difference methods. Tn that case, 'v' !> is not the average cell value, but rather the flux! See section 2.3.2, page 22. !> !> ARGUMENTS: !> k             order of reconstruction within the cell (k = 1, 2 or 3) !> vext          vector(1-(k-1):nc+(k-1)) of *average* cell values (if finite volume), !>               *extended* with (k-1) ghost cells on each side !> vl            vector(1:nc) of reconstructed v at left boundary of cell i (v_{i-1/2}&#94;+) !> vr            vector(1:nc) of reconstructed v at right boundary of cell i (v_{i+1/2}&#94;-) !> eps           numerical smoothing factor !> c(j,r,i)      optional array(0:k-1,-1:k-1,1:nc) of constants for a *non-uniform* grid !>               (see calc_c) !> !> NOTES: !> - For a scalar 1D problem, this procedure is called once per time step. In contrast, !>   for a scalar 2D problem, it is called (nc1+nc2) times per step. So, efficiency is !>   very important. The current implementation is rather general in terms of order and !>   grid type, but at the cost of a number of 'select case' constructs. I wonder if it !>   would be wise to make a specific version for k=2 (3rd order) and uniform grids to get !>   maximum performance for multi-dimensional problems. !>----------------------------------------------------------------------------------------- integer , intent ( in ) :: k real ( rk ), intent ( in ) :: eps , vext ( 2 - k :) real ( rk ), intent ( out ) :: vl (:), vr (:) real ( rk ), intent ( in ), target , optional :: c ( 0 :, - 1 :,:) real ( rk ), dimension ( 0 : k - 1 ) :: vlr , vrr , w , wtilde , alfa , alfatilde , beta real ( rk ), allocatable :: d (:), ci (:,:) integer :: i , r , nc logical :: usrgrid character (:), allocatable :: msg !> Select constant parameters according to order of the method select case ( k ) case ( 1 ) d = d1 ci = c1 case ( 2 ) d = d2 ci = c2 case ( 3 ) d = d3 ci = c3 case default msg = \"Invalid input 'k' in 'wenok'. Valid range: 1 <= k <= 3.\" error stop msg end select !> Check if user supplied grid if ( present ( c )) then usrgrid = . true . else usrgrid = . false . end if !> Algorithm !> Obtain the 'k' reconstructed values vi+1/2(r) & vi-1/2(r) !> Todo: change to 'do concurrent' nc = size ( vl ) do i = 1 , nc !> Equations 2.10, 2.51 if ( usrgrid ) ci = c (:,:, i ) do r = 0 , k - 1 vrr ( r ) = sum ( ci (:, r ) * vext ( i - r : i - r + k - 1 )) vlr ( r ) = sum ( ci (:, r - 1 ) * vext ( i - r : i - r + k - 1 )) end do select case ( k ) case ( 1 ) beta ( 0 ) = 0._rk !> Equation 2.62 case ( 2 ) beta ( 0 ) = ( vext ( i + 1 ) - vext ( i )) ** 2 beta ( 1 ) = ( vext ( i ) - vext ( i - 1 )) ** 2 !> Equation 2.63 case ( 3 ) beta ( 0 ) = 1 3._rk / 12 * ( vext ( i ) - 2 * vext ( i + 1 ) + vext ( i + 2 )) ** 2 & + 1._rk / 4 * ( 3 * vext ( i ) - 4 * vext ( i + 1 ) + vext ( i + 2 )) ** 2 beta ( 1 ) = 1 3._rk / 12 * ( vext ( i - 1 ) - 2 * vext ( i ) + vext ( i + 1 )) ** 2 & + 1._rk / 4 * ( vext ( i - 1 ) - vext ( i + 1 )) ** 2 beta ( 2 ) = 1 3._rk / 12 * ( vext ( i - 2 ) - 2 * vext ( i - 1 ) + vext ( i )) ** 2 & + 1._rk / 4 * ( vext ( i - 2 ) - 4 * vext ( i - 1 ) + 3 * vext ( i )) ** 2 end select !> Equations 2.58-2.59 and procedure 2.2-4 alfa = d / ( eps + beta ) ** 2 alfatilde = d ( k - 1 : 0 : - 1 ) / ( eps + beta ) ** 2 w = alfa / sum ( alfa ) wtilde = alfatilde / sum ( alfatilde ) !> Procedure 2.2-5 vr ( i ) = sum ( w * vrr ) vl ( i ) = sum ( wtilde * vlr ) end do end subroutine wenok pure subroutine calc_c ( k , xedges , c ) !>----------------------------------------------------------------------------------------- !>   This subroutine computes the array of constants 'c(j,r,i)' required to use 'wenok' with !> non-uniform grids. !> !> ARGUMENTS: !> k             order (>=1) of reconstruction within the cell !> xedges(i)     vector(0:nc) of cell edges !                xedges(i) is the value of x at right boundary of cell i (x_{i+1/2}) !                xedges(i-1) is the value of x at left boundary of cell i (x_{i-1/2}) !> c(j,r,i)      array(0:k-1,-1:k-1,1:nc) of constants for a non-uniform grid !> !> NOTES: !> - This procedure is only called a very small of times (as many as the number of spatial !>   dimensions) at the *start* of the simulation. So, there is no point in doing complex !>   optimizations. !>----------------------------------------------------------------------------------------- integer , intent ( in ) :: k real ( rk ), intent ( in ) :: xedges ( 0 :) real ( rk ), intent ( out ) :: c ( 0 :, - 1 :,:) real ( rk ) :: prod1 , prod2 , sum1 , sum2 , dx real ( rk ), allocatable , target :: xext (:) real ( rk ), dimension (:), pointer :: xl , xr integer :: i , j , l , nc , ng , m , q , r character (:), allocatable :: msg !> Check input conditions if ( k < 1 ) then msg = \"Invalid input 'k' in 'calc_c'. Valid range: k >= 1.\" error stop msg end if if ( k > 3 ) then msg = \"Input 'k' is probably too high in 'calc_c'. Usual range: k <= 3.\" error stop msg end if if ( ubound ( c , 1 ) /= k - 1 ) then msg = \"Invalid ubound(c,1) in 'calc_c'.\" error stop msg end if if ( ubound ( c , 2 ) /= k - 1 ) then msg = \"Invalid ubound(cgrid,2) in 'calc_c'.\" error stop msg end if nc = ubound ( xedges , 1 ) if ( ubound ( c , 3 ) /= nc ) then msg = \"Invalid ubound(cgrid,3) in 'calc_c'.\" error stop msg end if !> Allocate extended grid with (k+1) ghost cells on each side ng = k + 1 allocate ( xext ( 0 - ng : nc + ng )) xext ( 0 : nc ) = xedges !> Extend to the left linearly dx = xext ( 1 ) - xext ( 0 ) do i = - 1 , lbound ( xext , 1 ), - 1 xext ( i ) = xext ( i + 1 ) - dx end do !> Extend to the right linearly dx = xext ( nc ) - xext ( nc - 1 ) do i = nc + 1 , ubound ( xext , 1 ) xext ( i ) = xext ( i - 1 ) + dx end do !> Get pointers to left and right cell boundaries xl ( 1 - ng :) => xext ( lbound ( xext , 1 ): ubound ( xext , 1 ) - 1 ) xr ( 1 - ng :) => xext ( lbound ( xext , 1 ) + 1 : ubound ( xext , 1 )) !> Compute array of constants 'c' for each grid position !> Equation 2.20, page 6. do i = 1 , nc do r = - 1 , k - 1 do j = 0 , k - 1 sum2 = 0._rk do m = j + 1 , k prod2 = 1._rk do l = 0 , k if ( l == m ) cycle prod2 = prod2 * ( xl ( i - r + m ) - xl ( i - r + l )) end do sum1 = 0._rk do l = 0 , k if ( l == m ) cycle prod1 = 1._rk do q = 0 , k if ( q == m . or . q == l ) cycle prod1 = prod1 * ( xr ( i ) - xl ( i - r + q )) end do sum1 = sum1 + prod1 end do sum2 = sum2 + sum1 / prod2 end do c ( j , r , i ) = sum2 * ( xr ( i - r + j ) - xl ( i - r + j )) end do end do end do end subroutine calc_c end module weno","tags":"","loc":"sourcefile\\weno.f90.html"}]}